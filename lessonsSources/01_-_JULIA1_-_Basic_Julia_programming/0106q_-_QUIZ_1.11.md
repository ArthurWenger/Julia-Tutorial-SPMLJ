# Quiz 1.11: Metaprogramming and macros 

```@setup q011
cd(@__DIR__)    
using Pkg      
Pkg.activate(".")  
## Pkg.resolve()   
## Pkg.instantiate()
using Random
Random.seed!(123)
using QuizQuestions
```
--------------------------------------------------------------------------------
### Q1: 

Question text ?

```@example q011

choices = [ # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
] # hide
answers = []  # hide
multiq(choices, answers;)  # hide

```

```@raw html
<details><summary>RESOLUTION</summary>
```

Answer

The correct answers are:
  - 

```@raw html
</details>
```


::Julia-MetaprogrammingTheory::[markdown]
Which of the following statements are correct ?{
  ~%-100%[markdown] Metaprogramming in Julia refers to the possibility to change the text that defines the code statements before it is parsed 
  ~%-100%[markdown] Macros in Julia allow to write concise code that would otherwise raise a syntax error without the macro   
  ~%20%[markdown] Macros in Julia allow to programmatically transform one or more code expressions in a different expression
  ~%20%[markdown] Invoking a Julia macro implies making two different operations\: first "create" an expression, and then evaluating it
  ~%20%[markdown] A symbol allows to refer to an identifier rather than to the object associated (binded) to it
  ~%20%[markdown] Expressions are composed of symbols
  ~%20%[markdown] To evaluate an expression all the symbols referred in the expressions must be accessible at the global scope of where the evaluation happens
  ~%-100%[markdown] None of the (other) statements is correct
####[markdown] Concerning the wrong answers: the characteristic of metaprogramming in Julia is that the code is changed _after_ it is parsed in Expressions. For the same reasons we can't "go around" code that, without the macro, would create syntax errors (i.e. errors during parsing).  
}

--------------------------------------------------------------------------------
### Q1: 

Question text ?

```@example q011

choices = [ # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
] # hide
answers = []  # hide
multiq(choices, answers;)  # hide

```

```@raw html
<details><summary>RESOLUTION</summary>
```

Answer

The correct answers are:
  - 

```@raw html
</details>
```


::Julia-ExpressionComputation::[markdown]
Given the following code snippet:\n
```julia\nx = 10\ny = 3\nmyMult = Meta.parse("$x * y")\nx = 2\ny = 5\noutput = eval(myMult)\n```\n
Which of the following sentences are correct?{
  ~%-100%[markdown] 'out' is 30
  ~%100%[markdown] 'out' is 50
  ~%-100%[markdown] 'out' is 6
  ~%-100%[markdown] 'out' is 10
  ~%-100%[markdown] The code produce an error during parsing
  ~%-100%[markdown] The code produce an error during compilation or execution
  ~%-100%[markdown] None of the (other) sentences is correct
####[markdown] The expression is made by the _content_ of variable x (because we are using the dollar sign) that multiplies the variable y. The evaluation of what y contains, used to make the actual multiplication, is done at the time of evaluating the expression, so the multiplication that is done is 10 * 5}

--------------------------------------------------------------------------------
### Q2: 

Question text ?

```@example q011

numericq(value)  # hide

```

```@raw html
<details><summary>RESOLUTION</summary>
```

Answer

The correct answer is:

```@raw html
</details>
```



::Julia-ExpressionComponents::[markdown]
Given the following code snippet:\n
```julia\na         = [100,10,0]\nexpr      = Meta.parse("a[1]+1")\nexpr.XXXX = 2\n```\n
To what 'XXXX' should be replaced with in order for the evaluation of 'expr' to retun the value '11' ? (hint: you can dump the expression){=args[2].args[2]
####[markdown] We want to change the index of the array that we want to sum to the fixed value '1', so to have the expression to evaluate to '10+1' instead of '100+1'. The expression is made of several nested expressions. First, we have a call to the addition operator (+) (first argument), the 'a[1]' element (second argument) and the value 1 (third element). So we first want 'args[2]'. Then we have a reference expression where the first argument is the variable (symbol) 'a' and, finally, the second argument is the index value, '1' - that here we want to change to '2' -, so we have 'expr.args[2].args[2] \= 2'
}

--------------------------------------------------------------------------------
### Q1: 

Question text ?

```@example q011

choices = [ # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
    "", # hide
] # hide
answers = []  # hide
multiq(choices, answers;)  # hide

```

```@raw html
<details><summary>RESOLUTION</summary>
```

Answer

The correct answers are:
  - 

```@raw html
</details>
```


::Julia-MacroOutput::[markdown]
Given the following code snippet:\n
```julia\nmacro Foo(inExpr)\n    return 2\nend\n@Foo a=3\na\n```\n
Which of the following sentences are correct?{
  ~%-100%[markdown] 'a' is '2'
  ~%-100%[markdown] 'a' is '3'
  ~%100%[markdown] 'a' is not defined
  ~%-100%[markdown] The snipped return an error during parsing
  ~%-100%[markdown] None of the (other) sentences is correct
####[markdown] The script leads to an evaluation error (i.e., not a parsing one) as 'a' results not defined. The original expression of the assignment of 'a' to '3' is not part of the ASL, what it is is a single, constant value '2' that is what the invocation of the macro produces. However this is not binded to 'a', so 'a' in the expanded code is not even present. 
}






